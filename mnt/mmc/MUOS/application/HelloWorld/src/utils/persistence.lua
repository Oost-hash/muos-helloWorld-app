-- utils/persistence.lua - Save/Load System
-- Handles all file operations for device mappings and app state

local config = require("config")
local helpers = require("utils.helpers")

local persistence = {}

-- File operations
function persistence.fileExists(filename)
    local file = io.open(filename, "r")
    if file then
        file:close()
        return true
    end
    return false
end

-- Load device mapping from file
function persistence.loadDeviceMapping(filename)
    filename = filename or config.MAPPING_FILE
    
    print("Attempting to load mapping from: " .. filename)
    
    if not persistence.fileExists(filename) then
        print("Mapping file does not exist: " .. filename)
        return nil, "File does not exist"
    end
    
    local success, result = pcall(function()
        return dofile(filename)
    end)
    
    if not success then
        print("Error loading mapping file: " .. (result or "unknown error"))
        return nil, "Failed to load file: " .. (result or "unknown error")
    end
    
    if not result or type(result) ~= "table" then
        print("Invalid mapping file format")
        return nil, "Invalid file format"
    end
    
    -- Validate the loaded mapping
    local isValid, issues = persistence.validateMappingData(result)
    if not isValid then
        print("Mapping validation failed:")
        for _, issue in ipairs(issues) do
            print("  - " .. issue)
        end
        return nil, "Mapping validation failed"
    end
    
    print("Successfully loaded " .. helpers.countTableEntries(result) .. " button mappings")
    return result, nil
end

-- Save device mapping to file
function persistence.saveDeviceMapping(mapping, filename)
    filename = filename or config.MAPPING_FILE
    mapping = mapping or {}
    
    print("Saving mapping to: " .. filename)
    
    local file, error = io.open(filename, "w")
    if not file then
        local errorMsg = "Could not open file for writing: " .. (error or "unknown error")
        print("Save failed: " .. errorMsg)
        return false, errorMsg
    end
    
    -- Write file header
    file:write("-- Device mapping generated by " .. config.APP_NAME .. " v" .. config.APP_VERSION .. "\n")
    file:write("-- Generated on: " .. os.date("%Y-%m-%d %H:%M:%S") .. "\n")
    file:write("-- Total mappings: " .. helpers.countTableEntries(mapping) .. "\n\n")
    
    -- Write mapping table
    file:write("local deviceMapping = {\n")
    
    -- Sort keys for consistent output
    local sortedKeys = {}
    for key in pairs(mapping) do
        table.insert(sortedKeys, key)
    end
    table.sort(sortedKeys)
    
    for _, key in ipairs(sortedKeys) do
        local value = mapping[key]
        file:write("    " .. key .. " = {")
        file:write("type = \"" .. value.type .. "\", ")
        file:write("id = " .. tostring(value.id))
        
        if value.direction then
            file:write(", direction = \"" .. value.direction .. "\"")
        end
        
        file:write("},\n")
    end
    
    file:write("}\n\n")
    file:write("return deviceMapping\n")
    file:close()
    
    print("Mapping saved successfully (" .. helpers.countTableEntries(mapping) .. " entries)")
    return true, nil
end

-- Validate mapping data structure
function persistence.validateMappingData(mapping)
    if not mapping or type(mapping) ~= "table" then
        return false, {"Mapping is not a table"}
    end
    
    local issues = {}
    
    for key, value in pairs(mapping) do
        -- Check key format
        if type(key) ~= "string" or key == "" then
            table.insert(issues, "Invalid key: " .. tostring(key))
        end
        
        -- Check value structure
        if type(value) ~= "table" then
            table.insert(issues, "Value for " .. key .. " is not a table")
        else
            -- Check required fields
            if not value.type or type(value.type) ~= "string" then
                table.insert(issues, "Missing or invalid type for " .. key)
            end
            
            if not value.id or type(value.id) ~= "number" then
                table.insert(issues, "Missing or invalid id for " .. key)
            end
            
            -- Check input type validity
            if value.type and not helpers.isValidInputType(value.type) then
                table.insert(issues, "Invalid input type for " .. key .. ": " .. value.type)
            end
        end
    end
    
    return #issues == 0, issues
end

-- Create backup of existing mapping
function persistence.backupMapping(filename)
    filename = filename or config.MAPPING_FILE
    
    if not persistence.fileExists(filename) then
        return false, "No file to backup"
    end
    
    local backupName = filename .. ".backup." .. os.date("%Y%m%d_%H%M%S")
    local success, error = persistence.copyFile(filename, backupName)
    
    if success then
        print("Backup created: " .. backupName)
    else
        print("Backup failed: " .. (error or "unknown error"))
    end
    
    return success, error
end

-- Copy file
function persistence.copyFile(source, destination)
    local sourceFile, error = io.open(source, "r")
    if not sourceFile then
        return false, "Could not open source file: " .. (error or "unknown error")
    end
    
    local content = sourceFile:read("*all")
    sourceFile:close()
    
    local destFile, error = io.open(destination, "w")
    if not destFile then
        return false, "Could not open destination file: " .. (error or "unknown error")
    end
    
    destFile:write(content)
    destFile:close()
    
    return true, nil
end

-- Get mapping file info
function persistence.getMappingFileInfo(filename)
    filename = filename or config.MAPPING_FILE
    
    local info = {
        exists = false,
        size = 0,
        mappingCount = 0,
        isValid = false,
        lastModified = nil
    }
    
    if not persistence.fileExists(filename) then
        return info
    end
    
    info.exists = true
    
    -- Get file size
    local file = io.open(filename, "r")
    if file then
        file:seek("end")
        info.size = file:seek()
        file:close()
    end
    
    -- Try to load and count mappings
    local mapping, error = persistence.loadDeviceMapping(filename)
    if mapping then
        info.isValid = true
        info.mappingCount = helpers.countTableEntries(mapping)
    end
    
    return info
end

-- Export mapping in different formats
function persistence.exportMapping(mapping, format, filename)
    format = format or "lua"
    
    if format == "lua" then
        return persistence.saveDeviceMapping(mapping, filename)
    elseif format == "json" then
        return persistence.exportMappingAsJSON(mapping, filename)
    elseif format == "txt" then
        return persistence.exportMappingAsText(mapping, filename)
    else
        return false, "Unsupported export format: " .. format
    end
end

-- Export mapping as JSON (for other tools)
function persistence.exportMappingAsJSON(mapping, filename)
    filename = filename or "device_mapping.json"
    
    local file, error = io.open(filename, "w")
    if not file then
        return false, "Could not open file for writing: " .. (error or "unknown error")
    end
    
    -- Simple JSON export (no external JSON library needed)
    file:write("{\n")
    file:write("  \"app\": \"" .. config.APP_NAME .. "\",\n")
    file:write("  \"version\": \"" .. config.APP_VERSION .. "\",\n")
    file:write("  \"generated\": \"" .. os.date("%Y-%m-%d %H:%M:%S") .. "\",\n")
    file:write("  \"mappings\": {\n")
    
    local first = true
    for key, value in pairs(mapping) do
        if not first then
            file:write(",\n")
        end
        file:write("    \"" .. key .. "\": {")
        file:write("\"type\": \"" .. value.type .. "\", ")
        file:write("\"id\": " .. tostring(value.id))
        if value.direction then
            file:write(", \"direction\": \"" .. value.direction .. "\"")
        end
        file:write("}")
        first = false
    end
    
    file:write("\n  }\n")
    file:write("}\n")
    file:close()
    
    return true, nil
end

-- Export mapping as human-readable text
function persistence.exportMappingAsText(mapping, filename)
    filename = filename or "device_mapping.txt"
    
    local file, error = io.open(filename, "w")
    if not file then
        return false, "Could not open file for writing: " .. (error or "unknown error")
    end
    
    file:write(config.APP_NAME .. " v" .. config.APP_VERSION .. " - Device Mapping\n")
    file:write("Generated: " .. os.date("%Y-%m-%d %H:%M:%S") .. "\n")
    file:write("Total mappings: " .. helpers.countTableEntries(mapping) .. "\n\n")
    
    -- Group by type
    local buttonMappings = {}
    local axisMappings = {}
    local hatMappings = {}
    
    for key, value in pairs(mapping) do
        if value.type:find("button") then
            table.insert(buttonMappings, {key = key, value = value})
        elseif value.type:find("axis") then
            table.insert(axisMappings, {key = key, value = value})
        elseif value.type:find("hat") then
            table.insert(hatMappings, {key = key, value = value})
        end
    end
    
    -- Write buttons
    if #buttonMappings > 0 then
        file:write("BUTTONS:\n")
        for _, mapping in ipairs(buttonMappings) do
            file:write("  " .. mapping.key .. " -> " .. mapping.value.type .. ":" .. mapping.value.id .. "\n")
        end
        file:write("\n")
    end
    
    -- Write axes
    if #axisMappings > 0 then
        file:write("AXES:\n")
        for _, mapping in ipairs(axisMappings) do
            local direction = mapping.value.direction and (" (" .. mapping.value.direction .. ")") or ""
            file:write("  " .. mapping.key .. " -> " .. mapping.value.type .. ":" .. mapping.value.id .. direction .. "\n")
        end
        file:write("\n")
    end
    
    -- Write hats
    if #hatMappings > 0 then
        file:write("HATS (D-PAD):\n")
        for _, mapping in ipairs(hatMappings) do
            local direction = mapping.value.direction and (" (" .. mapping.value.direction .. ")") or ""
            file:write("  " .. mapping.key .. " -> " .. mapping.value.type .. ":" .. mapping.value.id .. direction .. "\n")
        end
    end
    
    file:close()
    return true, nil
end

return persistence